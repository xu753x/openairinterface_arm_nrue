/*
* Licensed to the OpenAirInterface (OAI) Software Alliance under one or more
* contributor license agreements.  See the NOTICE file distributed with
* this work for additional information regarding copyright ownership.
* The OpenAirInterface Software Alliance licenses this file to You under
* the OAI Public License, Version 1.1  (the "License"); you may not use this file
* except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.openairinterface.org/?page_id=698
*
* Author and copyright: Laurent Thomas, open-cells.com
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*-------------------------------------------------------------------------------
* For more information about the OpenAirInterface (OAI) Software Alliance:
*      contact@openairinterface.org
*/


#include <common/utils/simple_executable.h>
#include <sys/sendfile.h>

volatile int             oai_exit = 0;

#define shift 4
int32_t signal_energy(int32_t *input,uint32_t length) {
  int32_t i;
  int32_t temp,temp2;
  register __m64 mm0,mm1,mm2,mm3;
  __m64 *in = (__m64 *)input;
  mm0 = _mm_setzero_si64();//pxor(mm0,mm0);
  mm3 = _mm_setzero_si64();//pxor(mm3,mm3);

  for (i=0; i<length>>1; i++) {
    mm1 = in[i];
    mm2 = mm1;
    mm1 = _m_pmaddwd(mm1,mm1);
    mm1 = _m_psradi(mm1,shift);// shift any 32 bits blocs of the word by the value shift
    mm0 = _m_paddd(mm0,mm1);// add the two 64 bits words 4 bytes by 4 bytes
    //    mm2 = _m_psrawi(mm2,shift_DC);
    mm3 = _m_paddw(mm3,mm2);// add the two 64 bits words 2 bytes by 2 bytes
  }

  mm1 = mm0;
  mm0 = _m_psrlqi(mm0,32);
  mm0 = _m_paddd(mm0,mm1);
  temp = _m_to_int(mm0);
  temp/=length;
  temp<<=shift;   // this is the average of x^2
  // now remove the DC component
  mm2 = _m_psrlqi(mm3,32);
  mm2 = _m_paddw(mm2,mm3);
  mm2 = _m_pmaddwd(mm2,mm2);
  temp2 = _m_to_int(mm2);
  temp2/=(length*length);
  //  temp2<<=(2*shift_DC);
  temp -= temp2;
  _mm_empty();
  _m_empty();
  return((temp>0)?temp:1);
}

#define RS_head 256
void write_RS_header(int fd, ssize_t sz, int samplingRate) {
  const char l1[]="{TYPE: SMU-WV,0}";
  const char l2[]="{COMMENT: Generated by OAI}";
  const char l3[]="{DATE: %Y-%m-%d;%H:%M:%S}";
  const char l4[]="{LEVEL OFFS: 0.000000,0.00000}";
  const char l5[]="{CLOCK: %d}";
  const char l6[]="{SAMPLES: %ld}";
  const char l7[]="{WAVEFORM-%ld: #";
  int ret=0;
  ret+=write(fd,l1,strlen(l1));
  ret+=write(fd,l2,strlen(l2));
  time_t t=time(NULL);
  struct tm *tmp=localtime(&t);
  AssertFatal(tmp != NULL,"");
  char outstr[200];
  strftime(outstr, sizeof(outstr), l3, tmp);
  ret+=write(fd,outstr,strlen(outstr));
  ret+=write(fd,l4,strlen(l4));
  sprintf(outstr,l5,samplingRate);
  ret+=write(fd,outstr,strlen(outstr));
  sprintf(outstr,l6,sz);
  ret+=write(fd,outstr,strlen(outstr));
  sprintf(outstr,l7,sz*4+1);
  for (int i=lseek(fd,0,SEEK_CUR)+strlen(outstr); i<RS_head; i++)
    ret+=write(fd," ",1);
  ret+=write(fd,outstr,strlen(outstr));
  AssertFatal(ret==RS_head, "");
}

int main(int argc, char *argv[]) {
  if(argc < 5) {
    printf("This program converts\n a stored I/Q file in rfsimulator saved IQ format or\n a raw I/Q file (signed 16bits)\nto R&S format\nNeed parameters: source file, destination file,\n sampling rate in Hz,\n nb max of samples in output \n");
    exit(1);
  }

  int fdIn=open(argv[1],O_RDONLY);
  AssertFatal(fdIn != -1, "file: %s", argv[1]);
  off_t fileSize=lseek(fdIn, 0, SEEK_END);
  lseek(fdIn, 0, SEEK_SET);

  int fdOut=creat(argv[2], 0660);
  AssertFatal(fdOut != -1, "file: %s", argv[1]);

  int samplingRate=atoi(argv[3]);
  boolean_t raw=true;
  uint64_t magic;
  int ret=read(fdIn, &magic, sizeof(magic));
  AssertFatal(ret== sizeof(magic),"");
  if ( magic== UE_MAGICDL || magic == UE_MAGICUL || magic== ENB_MAGICDL || magic == ENB_MAGICUL )
    raw=false;
  lseek(fdIn, 0, SEEK_SET);

  int maxSamples=atoi(argv[4]);
  
  if (raw) {
    // sequence of 2*16 bits ints, as R&S we need only to add the header
    if (maxSamples*4 < fileSize)
      fileSize=maxSamples*4;
    write_RS_header(fdOut, fileSize, samplingRate);
    ssize_t bytesCopied=0;
    // We could consider rescaling
    while (bytesCopied != fileSize) { 
      ssize_t res = sendfile(fdOut, fdIn, &bytesCopied, fileSize);
      AssertFatal(res>0,"");
    }
  } else {
    samplesBlockHeader_t header, firstHeader;
    int bufSize=100000;
    void *buff=malloc(bufSize);
    AssertFatal(buff!=NULL,"");
    int ret=read(fdIn,&firstHeader,sizeof(header));
    AssertFatal(ret== sizeof(header),"");
    lseek(fdIn, 0, SEEK_SET);
    AssertFatal(firstHeader.nbAnt==1, "R&S SMBV is one Tx\n");
    uint64_t timestamp=firstHeader.timestamp;
    uint32_t zero=0,zeros[64]={0};

    // Reserve room for the header
    lseek(fdOut, RS_head, SEEK_SET);
    int nb=0;
    while (read(fdIn,&header,sizeof(header)) == sizeof(header) && nb <  maxSamples) {
      int dataSize=sizeof(int32_t)*header.size*header.nbAnt;
      AssertFatal(header.nbAnt==1,"");
      if (dataSize>bufSize) {
	void *new_buff = realloc(buff, dataSize);
	if (new_buff == NULL)
	  AssertFatal(false, "Could not reallocate");
	else
	  buff = new_buff;
      }
      while (timestamp+64 < header.timestamp && nb+64 < maxSamples){
	int ret=write(fdOut,&zeros,sizeof(zeros));
	AssertFatal(ret==sizeof(zeros),"");
	timestamp+=64;
	nb+=64;
      }
      while (timestamp <header.timestamp && nb < maxSamples){
	int ret=write(fdOut,&zero,sizeof(zero));
	AssertFatal(ret==sizeof(zero),"");
	timestamp++;
	nb++;
      }
      ssize_t ret=read(fdIn,buff,dataSize);
      AssertFatal(ret == dataSize, "");
      for (int i=0; i<header.size*header.nbAnt*2; i++)
        ((int16_t *)buff)[i]*=16;
      if (nb >= maxSamples)
	break; // we have already all samples
      if (nb+header.size > maxSamples) {
	header.size=maxSamples-nb;
	dataSize=sizeof(int32_t)*header.size*header.nbAnt;
      }
      ret=write(fdOut, buff, dataSize);
      AssertFatal(ret == dataSize, "%ld, %s", ret, strerror(errno));
      timestamp+=header.size;
      nb+=header.size;
    }
    printf("converted %ld samples, control: %d\n", timestamp-firstHeader.timestamp, nb);
    free(buff);
    lseek(fdOut, 0, SEEK_SET);
    write_RS_header(fdOut,timestamp-firstHeader.timestamp, samplingRate);
    lseek(fdOut, 0, SEEK_END);
  }

  int ret2=write(fdOut,"}",1);
  AssertFatal(ret2=1,"");
  close(fdOut);
  close(fdIn);
  return 0;
}
