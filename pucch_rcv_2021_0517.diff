diff --git a/nfapi/open-nFAPI/nfapi/public_inc/fapi_nr_ue_interface.h b/nfapi/open-nFAPI/nfapi/public_inc/fapi_nr_ue_interface.h
index 8b3cb6eec0..7456b4cb28 100644
--- a/nfapi/open-nFAPI/nfapi/public_inc/fapi_nr_ue_interface.h
+++ b/nfapi/open-nFAPI/nfapi/public_inc/fapi_nr_ue_interface.h
@@ -463,6 +463,8 @@ typedef struct {
   double scaling_factor_S;
   int8_t accumulated_delta_PUCCH;
   uint8_t pucch_resource_id;
+  uint8_t n_CCE;
+  uint8_t N_CCE;
   uint8_t pdsch_to_harq_feedback_time_ind;
   uint8_t n_dmrs_cdm_groups;
   uint8_t dmrs_ports[10];
diff --git a/openair1/PHY/NR_UE_TRANSPORT/dci_nr.c b/openair1/PHY/NR_UE_TRANSPORT/dci_nr.c
index fe4526908d..712aff2f58 100644
--- a/openair1/PHY/NR_UE_TRANSPORT/dci_nr.c
+++ b/openair1/PHY/NR_UE_TRANSPORT/dci_nr.c
@@ -995,6 +995,7 @@ uint8_t nr_dci_decoding_procedure(PHY_VARS_NR_UE *ue,
           dci_ind->slot = proc->nr_slot_rx;
           dci_ind->dci_list[dci_ind->number_of_dcis].rnti        = n_rnti;
           dci_ind->dci_list[dci_ind->number_of_dcis].n_CCE       = CCEind;
+          dci_ind->dci_list[dci_ind->number_of_dcis].N_CCE       = L;
           dci_ind->dci_list[dci_ind->number_of_dcis].dci_format  = rel15->dci_format_options[k];
           dci_ind->dci_list[dci_ind->number_of_dcis].payloadSize = dci_length;
           memcpy((void*)dci_ind->dci_list[dci_ind->number_of_dcis].payloadBits,(void*)dci_estimation,8);
diff --git a/openair1/SCHED_NR_UE/fapi_nr_ue_l1.c b/openair1/SCHED_NR_UE/fapi_nr_ue_l1.c
index fe3d25b6f7..7aa6e91825 100644
--- a/openair1/SCHED_NR_UE/fapi_nr_ue_l1.c
+++ b/openair1/SCHED_NR_UE/fapi_nr_ue_l1.c
@@ -120,6 +120,8 @@ int8_t nr_ue_scheduled_response(nr_scheduled_response_t *scheduled_response){
             dlsch0_harq->rvidx = dlsch_config_pdu->rv;
             dlsch0->g_pucch = dlsch_config_pdu->accumulated_delta_PUCCH;
             dlsch0_harq->harq_ack.pucch_resource_indicator = dlsch_config_pdu->pucch_resource_id;
+            dlsch0_harq->harq_ack.n_CCE = dlsch_config_pdu->n_CCE;
+            dlsch0_harq->harq_ack.N_CCE = dlsch_config_pdu->N_CCE;
             dlsch0_harq->harq_ack.slot_for_feedback_ack = (slot+dlsch_config_pdu->pdsch_to_harq_feedback_time_ind)%frame_parms.slots_per_frame;
             dlsch0_harq->Nl=1;
             dlsch0_harq->mcs_table=dlsch_config_pdu->mcs_table;
diff --git a/openair1/SCHED_NR_UE/phy_procedures_nr_ue.c b/openair1/SCHED_NR_UE/phy_procedures_nr_ue.c
index 51f01fcf4c..cee5554653 100644
--- a/openair1/SCHED_NR_UE/phy_procedures_nr_ue.c
+++ b/openair1/SCHED_NR_UE/phy_procedures_nr_ue.c
@@ -2120,7 +2120,7 @@ void nr_ue_prach_procedures(PHY_VARS_NR_UE *ue, UE_nr_rxtx_proc_t *proc, uint8_t
     LOG_D(PHY, "In %s: [UE %d] RA waiting contention resolution\n", __FUNCTION__, mod_id);
     ue->UE_mode[gNB_id] = RA_WAIT_CR;
   } else if (nr_prach == RA_SUCCEEDED) {
-    LOG_D(PHY, "In %s: [UE %d] RA completed, setting UE mode to PUSCH\n", __FUNCTION__, mod_id);
+    LOG_I(PHY, "In %s: [UE %d] RA completed, setting UE mode to PUSCH\n", __FUNCTION__, mod_id);
     ue->UE_mode[gNB_id] = PUSCH;
   } else if(nr_prach == RA_FAILED){
     LOG_D(PHY, "In %s: [UE %d] RA failed, setting UE mode to PRACH\n", __FUNCTION__, mod_id);
diff --git a/openair1/SCHED_NR_UE/pucch_uci_ue_nr.c b/openair1/SCHED_NR_UE/pucch_uci_ue_nr.c
index 865d0326cc..87c27765c6 100644
--- a/openair1/SCHED_NR_UE/pucch_uci_ue_nr.c
+++ b/openair1/SCHED_NR_UE/pucch_uci_ue_nr.c
@@ -419,6 +419,8 @@ bool pucch_procedures_ue_nr(PHY_VARS_NR_UE *ue, uint8_t gNB_id, UE_nr_rxtx_proc_
 
   NR_UE_MAC_INST_t *mac = get_mac_inst(0);
   NR_PUCCH_Resource_t *pucch_resource;
+  NR_PUCCH_Config_t *pucch_Config;
+
   uint16_t crnti = mac->crnti;
   NR_BWP_Id_t bwp_id = mac->UL_BWP_Id;
 
@@ -528,6 +530,8 @@ bool pucch_procedures_ue_nr(PHY_VARS_NR_UE *ue, uint8_t gNB_id, UE_nr_rxtx_proc_
     }
   }
 
+  if (O_ACK > 0)
+  LOG_I(PHY, "pucch bits O_SR %d, O_ACK %d, O_CSI %d, pucch_resource_set %d, pucch_resource_id %d, bwp id %d\n", O_SR, O_ACK, O_CSI, pucch_resource_set, pucch_resource_id, mac->UL_BWP_Id);
   N_UCI = O_SR + O_ACK + O_CSI;    
   if (N_UCI ==0) return(TRUE);
 
@@ -600,6 +604,7 @@ bool pucch_procedures_ue_nr(PHY_VARS_NR_UE *ue, uint8_t gNB_id, UE_nr_rxtx_proc_
     /**********************************************/
     else if ((pucch_resource_set != MAX_NB_OF_PUCCH_RESOURCE_SETS) && (pucch_resource_id != MAX_NB_OF_PUCCH_RESOURCES)) {
       /* check that current configuration is supported */
+      LOG_I(PHY, "came here\n");
       if (mac->cg &&
 	  mac->cg->physicalCellGroupConfig &&
           (mac->cg->physicalCellGroupConfig->harq_ACK_SpatialBundlingPUCCH != NULL ||
@@ -616,7 +621,7 @@ bool pucch_procedures_ue_nr(PHY_VARS_NR_UE *ue, uint8_t gNB_id, UE_nr_rxtx_proc_
         LOG_E(PHY,"PUCCH Unsupported code block group for serving cell config : at line %d in function %s of file %s \n", LINE_FILE , __func__, FILE_NAME);
         return(FALSE);
       }
-      NR_PUCCH_Config_t *pucch_Config;
+      //NR_PUCCH_Config_t *pucch_Config;
       if (bwp_id>0 &&
 	  mac->ULbwp[bwp_id-1] &&
 	  mac->ULbwp[bwp_id-1]->bwp_Dedicated &&
@@ -643,6 +648,9 @@ bool pucch_procedures_ue_nr(PHY_VARS_NR_UE *ue, uint8_t gNB_id, UE_nr_rxtx_proc_
       starting_symbol_index = get_starting_symb_idx(pucch_resource, format);
       startingPRB   = BWPstart + pucch_resource->startingPRB;
       secondHopPRB = pucch_resource->intraSlotFrequencyHopping ? (BWPstart+*pucch_resource->secondHopPRB) : startingPRB;
+
+      LOG_I(PHY, "came here: pucch_resource_id %d, format %d, nb_symbols_total %d, starting_symbol_index %d, startingPRB %d, secondHopPRB %d\n", 
+      pucch_resource_id, format, nb_symbols_total, starting_symbol_index, startingPRB, secondHopPRB);
       if (format==pucch_format1_nr)
         time_domain_occ = pucch_resource->format.choice.format1->timeDomainOCC;
       if (format==pucch_format4_nr) {
@@ -683,9 +691,11 @@ bool pucch_procedures_ue_nr(PHY_VARS_NR_UE *ue, uint8_t gNB_id, UE_nr_rxtx_proc_
   int O_CRC = 0;
 
   nb_symbols = nb_symbols_total; /* by default, it can be reduced due to symbols reserved for dmrs */
-  pucch_resource = format>1 ? 
-    mac->ULbwp[bwp_id-1]->bwp_Dedicated->pucch_Config->choice.setup->resourceToAddModList->list.array[pucch_resource_id]:
-    0;
+  //pucch_resource = format>1 ? 
+  //  mac->ULbwp[bwp_id-1]->bwp_Dedicated->pucch_Config->choice.setup->resourceToAddModList->list.array[pucch_resource_id]:
+  //  0;
+
+  AssertFatal(pucch_resource!=NULL,"PUCCH No compatible pucch format found : at line %d in function %s of file %s \n", LINE_FILE , __func__, FILE_NAME);
 
   switch(format) {
     case pucch_format0_nr:
@@ -733,16 +743,21 @@ bool pucch_procedures_ue_nr(PHY_VARS_NR_UE *ue, uint8_t gNB_id, UE_nr_rxtx_proc_
 
   /* TS 38.213 9.2.5.2 UE procedure for multiplexing HARQ-ACK/SR and CSI */
   /* drop CSI report if simultaneous HARQ-ACK/SR and periodic/semi-periodic CSI cannot be transmitted at the same time */
+  AssertFatal(pucch_Config!=NULL,"PUCCH No compatible pucch format found : at line %d in function %s of file %s \n", LINE_FILE , __func__, FILE_NAME);
+  LOG_I(PHY, "came here 2\n");
   if (format !=  pucch_format0_nr) {
-
-    if (mac->ULbwp[bwp_id-1]->bwp_Dedicated->pucch_Config->choice.setup->format1 != NULL) {
+    if (pucch_Config->format1->choice.setup != NULL){
+      #if 0
+    //if (mac->ULbwp[bwp_id-1]->bwp_Dedicated->pucch_Config->choice.setup->format1 != NULL) {
       //max_code_rate = code_rate_r_time_100[mac->ULbwp[bwp_id-1]->bwp_Dedicated->pucch_Config->choice.setup->format1->choice.setup->maxCodeRate[0]]; /* it is code rate * 10 */
 
-      if ((O_ACK != 0) && (mac->ULbwp[bwp_id-1]->bwp_Dedicated->pucch_Config->choice.setup->format1->choice.setup->simultaneousHARQ_ACK_CSI[0] == 0)) {
+      //if ((O_ACK != 0) && (mac->ULbwp[bwp_id-1]->bwp_Dedicated->pucch_Config->choice.setup->format1->choice.setup->simultaneousHARQ_ACK_CSI[0] == 0)) {
+        if ((O_ACK != 0) && (pucch_Config->format1->choice.setup->simultaneousHARQ_ACK_CSI[0] == 0)) {
         N_UCI = N_UCI - O_CSI;
         O_CSI = cqi_status = ri_status = 0;
         csi_payload = 0; /* csi should be dropped in this case */
       }
+      #endif
     }
 
     /* TS 38.212 6.3.1.2  Code block segmentation and CRC attachment */
@@ -756,7 +771,7 @@ bool pucch_procedures_ue_nr(PHY_VARS_NR_UE *ue, uint8_t gNB_id, UE_nr_rxtx_proc_
 //   else if (N_UCI >= 20) {
 //      O_CRC = 11; /* number of additional crc bits */
 //    }
-
+    LOG_I(PHY, "came here 3, N_UCI %d, O_CRC %d\n", N_UCI, O_CRC);
     N_UCI = N_UCI + O_CRC;
 
     /* for format 2 and 3, number of prb should be adjusted to minimum value which cope to information size */
@@ -859,7 +874,7 @@ bool pucch_procedures_ue_nr(PHY_VARS_NR_UE *ue, uint8_t gNB_id, UE_nr_rxtx_proc_
 #else
   tx_amp = AMP;
 #endif
-
+    LOG_I(PHY, "came here 4\n");
   switch(format) {
     case pucch_format0_nr:
     {
@@ -1216,6 +1231,7 @@ boolean_t select_pucch_resource(PHY_VARS_NR_UE *ue, NR_UE_MAC_INST_t *mac, uint8
 
     if (ue->UE_mode[gNB_id] != PUSCH) {
       *initial_pucch_id = *mac->scc_SIB->uplinkConfigCommon->initialUplinkBWP.pucch_ConfigCommon->choice.setup->pucch_ResourceCommon;
+      LOG_I(PHY, "no dedicated, no PUSCH mode %d\n", *initial_pucch_id);
       if (*initial_pucch_id >= NB_INITIAL_PUCCH_RESOURCE) {
         LOG_E(PHY,"PUCCH Invalid initial resource index : at line %d in function %s of file %s \n", LINE_FILE , __func__, FILE_NAME);
         *initial_pucch_id = NB_INITIAL_PUCCH_RESOURCE;
@@ -1236,10 +1252,12 @@ boolean_t select_pucch_resource(PHY_VARS_NR_UE *ue, NR_UE_MAC_INST_t *mac, uint8
       }
       int r_PUCCH = ((2 * n_CCE_0)/N_CCE_0) + (2 * delta_PRI);
       *initial_pucch_id = r_PUCCH;
+      LOG_I(PHY, "no dedicated, PUSCH mode %d, delta_PRI %d, n_CCE_0 %d, N_CCE_0 %d\n", *initial_pucch_id, delta_PRI, n_CCE_0, N_CCE_0);
     }
     nb_symbols_for_tx = initial_pucch_resource[*initial_pucch_id].nrofSymbols;
     format_pucch = initial_pucch_resource[*initial_pucch_id].format;
     if (check_pucch_format(mac, gNB_id, format_pucch, nb_symbols_for_tx, uci_size) == TRUE) {
+      LOG_I(PHY, "no dedicated, check_pucch_format ok, nb_symbols_for_tx %d, format_pucch %d\n", *initial_pucch_id, nb_symbols_for_tx, format_pucch);
       return (TRUE);
     }
     else {
@@ -1263,11 +1281,14 @@ boolean_t select_pucch_resource(PHY_VARS_NR_UE *ue, NR_UE_MAC_INST_t *mac, uint8
       if (pucch_resource_set_id != MAX_NB_OF_PUCCH_RESOURCE_SETS) {
         resource_set_found = TRUE;
       }
+
+      LOG_I(PHY, "dedicated: resource_set_found %d, pucch_resource_set_id %d, pucch_resource_indicator %d", resource_set_found, pucch_resource_set_id, pucch_resource_indicator);
     }
     else {
       /* a valid resource has already be found outside this function */
       resource_set_found = TRUE;
       ready_pucch_resource_id = TRUE;
+      LOG_I(PHY, "dedicated: set outside, resource_set_found %d, pucch_resource_set_id %d, pucch_resource_indicator %d", resource_set_found, pucch_resource_set_id, pucch_resource_indicator);
       //pucch_resource_indicator = pucch_resource_indicator;
     }
 
@@ -1320,6 +1341,7 @@ boolean_t select_pucch_resource(PHY_VARS_NR_UE *ue, NR_UE_MAC_INST_t *mac, uint8
             }
             else {
 		current_resource_id = resourceSetToAddModList->list.array[pucch_resource_set_id]->resourceList.list.array[pucch_resource_indicator][0];
+               LOG_I(PHY, "current_resource_id %d\n", current_resource_id);
             }
           }
 
diff --git a/openair2/LAYER2/NR_MAC_COMMON/nr_mac.h b/openair2/LAYER2/NR_MAC_COMMON/nr_mac.h
index ba12d9c5c3..d5c85a6c73 100644
--- a/openair2/LAYER2/NR_MAC_COMMON/nr_mac.h
+++ b/openair2/LAYER2/NR_MAC_COMMON/nr_mac.h
@@ -268,6 +268,8 @@ typedef struct {
   uint8_t     short_messages_indicator; //2 bits
   uint8_t     short_messages; //8 bits
   uint8_t     tb_scaling; //2 bits
+  uint8_t     n_CCE;
+  uint8_t     N_CCE;
   uint8_t     pucch_resource_indicator; //3 bits
   uint8_t     system_info_indicator; //1 bit
   uint8_t     ulsch_indicator;
diff --git a/openair2/LAYER2/NR_MAC_UE/config_ue.c b/openair2/LAYER2/NR_MAC_UE/config_ue.c
index 32226a4ea6..a5cffbcffe 100755
--- a/openair2/LAYER2/NR_MAC_UE/config_ue.c
+++ b/openair2/LAYER2/NR_MAC_UE/config_ue.c
@@ -595,6 +595,7 @@ void config_control_ue(NR_UE_MAC_INST_t *mac){
 
   uint8_t coreset_id = 1, ss_id;
 
+  LOG_I(MAC, "config_control_ue\n");
   NR_ServingCellConfig_t *scd = mac->cg->spCellConfig->spCellConfigDedicated;
   AssertFatal(scd->downlinkBWP_ToAddModList != NULL, "downlinkBWP_ToAddModList is null\n");
   AssertFatal(scd->downlinkBWP_ToAddModList->list.count == 1, "downlinkBWP_ToAddModList->list->count is %d\n", scd->downlinkBWP_ToAddModList->list.count);
diff --git a/openair2/LAYER2/NR_MAC_UE/nr_ue_procedures.c b/openair2/LAYER2/NR_MAC_UE/nr_ue_procedures.c
index 45515fc74e..c64c5173d0 100644
--- a/openair2/LAYER2/NR_MAC_UE/nr_ue_procedures.c
+++ b/openair2/LAYER2/NR_MAC_UE/nr_ue_procedures.c
@@ -732,6 +732,8 @@ int8_t nr_ue_process_dci(module_id_t module_id, int cc_id, uint8_t gNB_index, fr
     //if (dci->pucch_resource_indicator == 6) dlsch_config_pdu_1_0->pucch_resource_id = 7; //pucch-ResourceId obtained from the 7th value of resourceList FIXME!!
     //if (dci->pucch_resource_indicator == 7) dlsch_config_pdu_1_0->pucch_resource_id = 8; //pucch-ResourceId obtained from the 8th value of resourceList FIXME!!
     dlsch_config_pdu_1_0->pucch_resource_id = dci->pucch_resource_indicator;
+    dlsch_config_pdu_1_0->n_CCE = dci->n_CCE;
+    dlsch_config_pdu_1_0->N_CCE = dci->N_CCE;
     // Sanity check for pucch_resource_indicator value received to check for false DCI.
     valid = 0;
     if (mac->ULbwp[0] &&
diff --git a/openair2/RRC/NR_UE/rrc_UE.c b/openair2/RRC/NR_UE/rrc_UE.c
index c8b620887c..535ffb2715 100644
--- a/openair2/RRC/NR_UE/rrc_UE.c
+++ b/openair2/RRC/NR_UE/rrc_UE.c
@@ -2437,7 +2437,7 @@ int8_t nr_rrc_ue_decode_ccch( const protocol_ctxt_t *const ctxt_pP, const NR_SRB
 	       NR_RRC_MAC_CCCH_DATA_IND (msg_p).rnti,
 	       ITTI_MSG_NAME (msg_p),
 	       NR_RRC_MAC_CCCH_DATA_IND (msg_p).frame,
-	       NR_RRC_MAC_CCCH_DATA_IND (msg_p).gnb_index，
+	       NR_RRC_MAC_CCCH_DATA_IND (msg_p).gnb_index,
          NR_RRC_MAC_CCCH_DATA_IND (msg_p).sdu_size);
 	 srb_info_p = &NR_UE_rrc_inst[ue_mod_id].Srb0[NR_RRC_MAC_CCCH_DATA_IND (msg_p).gnb_index];
 	 memcpy (srb_info_p->Rx_buffer.Payload, NR_RRC_MAC_CCCH_DATA_IND (msg_p).sdu,
